package rule

# Vulnerability Scanner Rule - Template
#
# This rule evaluates vulnerability scan results against policy thresholds.
# It uses severity-based evaluation with exception handling and location exclusions.
#
# See CUSTOMIZATION.md for detailed guidance on adapting this rule.

# Define all possible result states as defaults
# IMPORTANT: Always define all states, even if you don't use them
default fail = false
default inProgress = false
default notFound = false
default notRequired = false
default pass = false
default warn = false

# Import future keywords for better Rego syntax
import future.keywords

# ============================================================================
# Helper Functions
# ============================================================================

# Check if a vulnerability matches a specific severity level
isLevel(level, vuln_level) if {
	level == vuln_level
}

# Check if a vulnerability is in the exception list
# This checks CWE IDs against the exception list
isException(vuln, exceptions) if {
	# Check if any of the vulnerability's CWEs match an exception
	some cwe in vuln.cwe
	some exception
	exception = exceptions[_]
	exception == cwe
}

# Alternative: Check if vulnerability ID is in exception list
# Uncomment this if your exceptions are by CVE/vulnerability ID instead of CWE
# isException(vuln, exceptions) if {
#     some exception
#     exception = exceptions[_]
#     exception == vuln.identifier
# }

# Check if a vulnerability's location should be excluded
# This checks if any of the vulnerability's file locations match an exclusion pattern
isExcludedLocation(vuln) if {
	# Check each location in the vulnerability
	some location in vuln.locations

	# Check each exclusion pattern
	some exclusion
	exclusion = data.exclusions.locations[_]

	# Use startswith for directory-level exclusions (e.g., "test/" excludes all test files)
	# TODO: Change to exact match if you want to exclude specific files only
	startswith(location.file, exclusion)
}

# Alternative location matching approaches:
#
# Exact file match:
# isExcludedLocation(vuln) if {
#     some location in vuln.locations
#     some exclusion
#     exclusion = data.exclusions.locations[_]
#     exclusion == location.file
# }
#
# Regex match (if OPA supports it in your version):
# isExcludedLocation(vuln) if {
#     some location in vuln.locations
#     some exclusion
#     exclusion = data.exclusions.locations[_]
#     regex.match(exclusion, location.file)
# }

# Combined check: is a vulnerability OK (not a violation)?
# Returns false if:
# - Vulnerability is at the specified level AND
# - It's not in the exception list AND
# - Its location is not excluded
#
# Returns true if:
# - Vulnerability is at a different level OR
# - It's in the exception list OR
# - Its location is excluded
isOk(level, vuln, exceptions) := false if {
	# Vulnerability is at this severity level
	isLevel(level, vuln.level)

	# Not in exception list
	not isException(vuln, exceptions)

	# Location not excluded
	not isExcludedLocation(vuln)
}

# Vulnerability passes checks if it's a different level
isOk(level, vuln, exceptions) if {
	not isLevel(level, vuln.level)
}

# Vulnerability passes checks if it's in exception list
isOk(level, vuln, exceptions) if {
	isException(vuln, exceptions)
}

# Vulnerability passes checks if location is excluded
isOk(level, vuln, exceptions) if {
	isExcludedLocation(vuln)
}

# ============================================================================
# Main Pass Rule
# ============================================================================

pass if {
	# Get vulnerability data from mapper output
	detail := input.detail

	# Count critical severity violations
	# This iterates through all vulnerabilities and counts those that:
	# 1. Are at "critical" severity level
	# 2. Are NOT in the exception list
	# 3. Are NOT in an excluded location
	critical := count([
		v |
		v := detail.vulnerabilities[_]
		check := isOk("critical", v, data.vulnerabilities.critical.exceptions)

		# Build violation object with relevant fields
		# This is what gets recorded when a violation occurs
		# TODO: Customize to include fields most useful for your debugging
		violation := {
			"level": v.level,
			"identifier": v.identifier,
			"description": v.description,
			"cwe": v.cwe,
			"priority": v.priority,
			"categories": v.categories,
		}

		# Record the violation for UI display
		fianu.record_violation(check, violation)

		# Count this vulnerability if it failed the check
		not check
	])

	# Count high severity violations
	high := count([
		v |
		v := detail.vulnerabilities[_]
		check := isOk("high", v, data.vulnerabilities.high.exceptions)
		violation := {
			"level": v.level,
			"identifier": v.identifier,
			"description": v.description,
			"cwe": v.cwe,
			"priority": v.priority,
			"categories": v.categories,
		}
		fianu.record_violation(check, violation)
		not check
	])

	# Count medium severity violations
	medium := count([
		v |
		v := detail.vulnerabilities[_]
		check := isOk("medium", v, data.vulnerabilities.medium.exceptions)
		violation := {
			"level": v.level,
			"identifier": v.identifier,
			"description": v.description,
			"cwe": v.cwe,
			"priority": v.priority,
			"categories": v.categories,
		}
		fianu.record_violation(check, violation)
		not check
	])

	# Count low severity violations
	low := count([
		v |
		v := detail.vulnerabilities[_]
		check := isOk("low", v, data.vulnerabilities.low.exceptions)
		violation := {
			"level": v.level,
			"identifier": v.identifier,
			"description": v.description,
			"cwe": v.cwe,
			"priority": v.priority,
			"categories": v.categories,
		}
		fianu.record_violation(check, violation)
		not check
	])

	# Check that all counts are within policy thresholds
	critical <= data.vulnerabilities.critical.maximum
	high <= data.vulnerabilities.high.maximum
	medium <= data.vulnerabilities.medium.maximum
	low <= data.vulnerabilities.low.maximum
}

# ============================================================================
# Not Required Rule
# ============================================================================

# Control is not required if:
# - It didn't pass AND
# - Policy has required = false
notRequired if {
	not pass
	data.required == false
}

# ============================================================================
# Debugging Tips
# ============================================================================
#
# To debug this rule, you can add trace() statements:
#
# trace(sprintf("Critical count: %v, Max: %v", [critical, data.vulnerabilities.critical.maximum]))
#
# To test locally with OPA:
#
# opa eval -d rule.rego \
#   -i ../testing/payloads/occ_passing.json \
#   -d ../inputs/data/policy_strict.json \
#   "data.rule.pass"
#
# ============================================================================

# ============================================================================
# Customization Examples
# ============================================================================
#
# Add a new severity level (e.g., "informational"):
#
# informational := count([
#     v |
#     v := detail.vulnerabilities[_]
#     check := isOk("informational", v, data.vulnerabilities.informational.exceptions)
#     violation := { ... }
#     fianu.record_violation(check, violation)
#     not check
# ])
#
# informational <= data.vulnerabilities.informational.maximum
#
# ============================================================================
#
# Add package-based exceptions:
#
# isPackageException(vuln) if {
#     some location in vuln.locations
#     some exception
#     exception = data.vulnerabilities.critical.package_exceptions[_]
#     exception == location.package
# }
#
# isOk(level, vuln, exceptions) if {
#     isPackageException(vuln)
# }
#
# ============================================================================
#
# Check total vulnerabilities across all levels:
#
# pass if {
#     detail := input.detail
#     total := count(detail.vulnerabilities)
#     total <= data.total_maximum
# }
#
# ============================================================================
