# Vulnerability Scanner Template - Customization Guide

Step-by-step guide to customize this template for your specific security scanning tool.

## Table of Contents

1. [Before You Start](#before-you-start)
2. [Step 1: Understand Your Data](#step-1-understand-your-data)
3. [Step 2: Customize spec.yaml](#step-2-customize-specyaml)
4. [Step 3: Customize detail.py](#step-3-customize-detailpy)
5. [Step 4: Customize display.py](#step-4-customize-displaypy)
6. [Step 5: Customize rule.rego](#step-5-customize-rule-rego)
7. [Step 6: Create Test Data](#step-6-create-test-data)
8. [Step 7: Test Everything](#step-7-test-everything)
9. [Step 8: Deploy](#step-8-deploy)
10. [Common Customizations](#common-customizations)

---

## Before You Start

### What You Need

1. **Sample occurrence data** from your security scanning tool
   - Export a real scan result
   - Include various severity levels
   - Save as JSON

2. **Tool documentation**
   - Data format specification
   - Field definitions
   - Severity level mapping

3. **Policy requirements**
   - What thresholds make sense for your org
   - What exceptions are needed
   - What files/paths to exclude

### Checklist

- [ ] Sample scan result saved as JSON
- [ ] Understanding of tool's data format
- [ ] List of required policy fields
- [ ] New UUIDs generated (use `uuidgen` or online tool)

---

## Step 1: Understand Your Data

### 1.1 Examine Your Occurrence Structure

Load your sample scan result and identify:

```python
# Example occurrence structure
{
  "detail": {
    "scan": { ... },           # Where is the scan data?
    "results": [ ... ],        # Where are the vulnerabilities?
    "metadata": { ... }        # Any metadata needed?
  }
}
```

### 1.2 Map Your Severity Levels

Identify how your tool represents severity:

**SARIF Standard:**
```json
{
  "level": "error",            # error, warning, note
  "properties": {
    "priorityScore": 850       # 0-1000
  }
}
```

**Checkmarx Example:**
```json
{
  "resultStatistics": {
    "criticalSeverity": 5,
    "highSeverity": 12,
    "mediumSeverity": 45,
    "lowSeverity": 102
  }
}
```

**Snyk Example:**
```json
{
  "vulnerabilities": [
    {
      "severity": "critical",  # critical, high, medium, low
      "id": "SNYK-JS-...",
      "title": "...",
      "identifiers": {
        "CWE": ["CWE-79"]
      }
    }
  ]
}
```

### 1.3 Identify Exception Fields

What fields should support exceptions?
- CVE IDs (`CVE-2023-1234`)
- CWE IDs (`CWE-79`, `CWE-89`)
- Package names
- Rule IDs
- Custom identifiers

### 1.4 Identify Location Fields

Where are file paths stored?
- SARIF: `result.locations[].physicalLocation.artifactLocation.uri`
- Custom: `result.fileName`, `result.path`, etc.

---

## Step 2: Customize spec.yaml

### 2.1 Generate New UUIDs

Generate UUIDs for these fields:
```bash
# Generate 10+ UUIDs at once
for i in {1..15}; do uuidgen; done
```

You need UUIDs for:
- Control `id`
- Each measure `node_id` (one per measure/section)

### 2.2 Update Control Metadata

In `spec.yaml.template`, replace these TODOs:

```yaml
# TODO: Generate new UUID for this control
id: <YOUR_NEW_UUID>

# TODO: Short display key (3-6 chars, uppercase)
displayKey: SNYK  # or CKMX, WIZ, GLAB, etc.

# TODO: Control path (matches directory name, dot notation)
path: snyk.sast.vulnerabilities  # or checkmarx.sast.scan, etc.

# TODO: Short name
name: Snyk SAST

# TODO: Full descriptive name
fullName: Snyk Static Application Security Testing (SAST)

# TODO: Description of what this control evaluates
description: |
  This control evaluates Snyk SAST scan results against policy-defined
  thresholds for vulnerability severity levels (critical, high, medium, low).

  The policy allows configuration of maximum allowed vulnerabilities per
  severity level, with support for exceptions (specific CVE/CWE exclusions)
  and location exclusions (file path patterns to ignore).
```

### 2.3 Update Relations

```yaml
relations:
- isPrimary: false
  collection: 6253b179-630e-46d7-9aa8-88c446a14aaf  # Standard collection UUID
  domain: 09c27275-3aaa-4530-bb62-07dc02d3b63c      # Standard domain UUID
  subscription:
    # TODO: Update to match your occurrence path
    path: security.sast.snyk              # Example: security.sast.snyk
    integration:
      type: plugin
      # TODO: Update to match your plugin name
      path: snyk-sast                     # Example: snyk-sast, checkmarx, wiz
    note: occurrence
```

**Finding the right paths:**
- `subscription.path`: Ask your integration team or check occurrence data
- `integration.path`: Usually matches your plugin/integration name

### 2.4 Update Measure node_ids

Replace ALL TODO node_id values with unique UUIDs:

```yaml
measures:
- name: required
  type: metric
  value: bool
  node_id: <UUID_1>  # TODO: Replace with new UUID

- name: vulnerabilities
  type: section
  node_id: <UUID_2>  # TODO: Replace with new UUID
  children:
  - name: critical
    type: section
    node_id: <UUID_3>  # TODO: Replace with new UUID
    children:
    - name: maximum
      type: metric
      value: number
      node_id: <UUID_4>  # TODO: Replace with new UUID
    - name: exceptions
      type: metric
      value: array.string
      node_id: <UUID_5>  # TODO: Replace with new UUID
  # ... continue for high, medium, low
```

### 2.5 Adjust Measures (Optional)

**Add/remove severity levels:**

If your tool only has `critical`, `high`, `medium` (no `low`):
```yaml
vulnerabilities:
  children:
  - name: critical
    # ...
  - name: high
    # ...
  - name: medium
    # ...
  # Remove low section entirely
```

**Add informational severity:**
```yaml
  - name: informational
    type: section
    children:
    - name: maximum
      type: metric
      value: number
    - name: exceptions
      type: metric
      value: array.string
```

---

## Step 3: Customize detail.py

### 3.1 If Your Tool Uses SARIF

The template includes complete SARIF parsing. You may only need to adjust:

**Severity mapping:**
```python
# SARIF uses "error", "warning", "note"
# Map to critical/high/medium/low

def map_severity(sarif_level, priority_score):
    """Map SARIF level to standard severity."""
    if sarif_level == "error":
        if priority_score >= 800:
            return "critical"
        return "high"
    elif sarif_level == "warning":
        if priority_score >= 500:
            return "medium"
        return "low"
    return "informational"
```

**CWE extraction:**
```python
# Adjust based on where your tool stores CWE
def get_cwes(rule):
    # Option 1: In rule properties
    return rule.get('properties', {}).get('cwe', [])

    # Option 2: In tags
    return [tag for tag in rule.get('properties', {}).get('tags', [])
            if tag.startswith('CWE')]

    # Option 3: In security-severity
    cwe_list = rule.get('properties', {}).get('security-severity', '')
    return [cwe.strip() for cwe in cwe_list.split(',')]
```

### 3.2 If Your Tool Does NOT Use SARIF

Replace the entire `main()` function. Keep this return structure:

```python
def main(occurrence, context):
    """
    Extract vulnerability data from your tool's format.

    Returns:
        dict: {
            'summary': {
                'critical': int,
                'high': int,
                'medium': int,
                'low': int,
                'total': int
            },
            'vulnerabilities': [
                {
                    'level': str,              # critical, high, medium, low
                    'identifier': str,          # CVE, CWE, or custom ID
                    'description': str,
                    'cwe': list[str],          # ['CWE-79', 'CWE-89']
                    'locations': list[dict]    # File paths
                },
                ...
            ],
            'scan': {                          # Optional metadata
                'id': str,
                'url': str,
                'timestamp': str
            }
        }
    """
    pass
```

### 3.3 Example: Checkmarx API Response

```python
def main(occurrence, context):
    """Extract Checkmarx scan data."""
    occ = occurrence.get('detail', {})
    scan_details = occ.get('scanDetails', {})
    result_stats = scan_details.get('resultStatistics', {})

    # Extract summary counts
    critical = result_stats.get('criticalSeverity', 0)
    high = result_stats.get('highSeverity', 0)
    medium = result_stats.get('mediumSeverity', 0)
    low = result_stats.get('lowSeverity', 0)

    # Extract individual results
    results = occ.get('results', [])
    vulnerabilities = []

    for result in results:
        vuln = {
            'level': result.get('severity', '').lower(),
            'identifier': result.get('vulnerabilityId', ''),
            'description': result.get('description', ''),
            'cwe': [result.get('cweId', '')],
            'locations': [{
                'file': result.get('fileName', ''),
                'line': result.get('line', 0)
            }]
        }
        vulnerabilities.append(vuln)

    return {
        'summary': {
            'critical': critical,
            'high': high,
            'medium': medium,
            'low': low,
            'total': critical + high + medium + low
        },
        'vulnerabilities': vulnerabilities,
        'scan': {
            'id': scan_details.get('scanId', ''),
            'project': scan_details.get('projectName', ''),
            'url': scan_details.get('reportLink', '')
        }
    }
```

### 3.4 Example: Snyk JSON Output

```python
def main(occurrence, context):
    """Extract Snyk vulnerability data."""
    occ = occurrence.get('detail', {})
    vulns_data = occ.get('vulnerabilities', [])

    vulnerabilities = []
    counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}

    for vuln in vulns_data:
        severity = vuln.get('severity', 'low')
        counts[severity] = counts.get(severity, 0) + 1

        # Extract CWEs from identifiers
        cwes = []
        identifiers = vuln.get('identifiers', {})
        if 'CWE' in identifiers:
            cwes = identifiers['CWE']

        vulnerabilities.append({
            'level': severity,
            'identifier': vuln.get('id', ''),
            'description': vuln.get('title', ''),
            'cwe': cwes,
            'locations': [{
                'file': vuln.get('from', [''])[0] if vuln.get('from') else '',
                'package': vuln.get('packageName', '')
            }]
        })

    return {
        'summary': {
            **counts,
            'total': len(vulnerabilities)
        },
        'vulnerabilities': vulnerabilities
    }
```

### 3.5 Error Handling

Always handle missing/null data:

```python
# Good - handles None
def main(occurrence, context):
    detail = occurrence.get('detail', {})
    results = detail.get('results', [])

    if not results:
        return {
            'summary': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'total': 0},
            'vulnerabilities': []
        }

    # ... process results

# Bad - will crash on None
def main(occurrence, context):
    results = occurrence['detail']['results']  # KeyError if missing
    for r in results:  # TypeError if results is None
        pass
```

---

## Step 4: Customize display.py

### 4.1 Update Description

```python
def main(occurrence, attestation, context):
    # TODO: Customize this description
    _description = "Snyk Static Application Security Testing (SAST) evaluates " \
                   "source code for security vulnerabilities. Policy enforces " \
                   "maximum thresholds for each severity level with support for " \
                   "CVE/CWE exceptions and file path exclusions."
```

### 4.2 Update Tag

The tag shows in the UI as a quick summary. Common patterns:

**Show critical and high counts:**
```python
_summary = _detail.get('summary', {})
critical = _summary.get('critical', 0)
high = _summary.get('high', 0)

return {
    'description': _description,
    'tag': f'Critical ({critical}), High ({high})'
}
```

**Show total violations:**
```python
total = _summary.get('total', 0)
return {
    'description': _description,
    'tag': f'{total} Total Vulnerabilities'
}
```

**Show scan metadata:**
```python
scan = _detail.get('scan', {})
return {
    'description': _description,
    'tag': f'Scan #{scan.get("id", "N/A")} - {scan.get("project", "Unknown")}'
}
```

### 4.3 Customize Violation Columns (Optional)

If you want violations to show in the UI, add a `violations` section:

```python
return {
    'description': _description,
    'tag': f'Critical ({critical}), High ({high})',
    'violations': {
        'columns': {
            'level': {
                'name': 'Severity',
                'type': 'string'
            },
            'identifier': {
                'name': 'CVE/CWE',
                'type': 'string'
            },
            'description': {
                'name': 'Description',
                'type': 'string'
            },
            'locations.0.file': {
                'name': 'File',
                'type': 'string'
            }
        }
    }
}
```

**Column types:**
- `string`: Plain text
- `number`: Numeric value
- `email`: Email address
- `url`: Clickable link

---

## Step 5: Customize rule.rego

### 5.1 If Using Standard Severity Levels

The template rule should work as-is. You may only need to adjust exception logic.

### 5.2 Adjust Exception Matching

**Match by CWE:**
```rego
isException(vuln, exceptions) if {
    some cwe in vuln.cwe
    some exception
    exception = exceptions[_]
    exception == cwe
}
```

**Match by CVE:**
```rego
isException(vuln, exceptions) if {
    some exception
    exception = exceptions[_]
    exception == vuln.identifier
}
```

**Match by package name:**
```rego
isException(vuln, exceptions) if {
    some location in vuln.locations
    some exception
    exception = exceptions[_]
    exception == location.package
}
```

**Match multiple criteria:**
```rego
isException(vuln, exceptions) if {
    some exception
    exception = exceptions[_]
    # Match by CWE
    exception == vuln.cwe[_]
} {
    some exception
    exception = exceptions[_]
    # OR match by CVE
    exception == vuln.identifier
}
```

### 5.3 Adjust Location Exclusions

**Exact match:**
```rego
isExcludedLocation(vuln) if {
    some location in vuln.locations
    some exclusion
    exclusion = data.exclusions.locations[_]
    exclusion == location.file
}
```

**Prefix match (exclude directories):**
```rego
isExcludedLocation(vuln) if {
    some location in vuln.locations
    some exclusion
    exclusion = data.exclusions.locations[_]
    startswith(location.file, exclusion)
}
```

**Regex match (requires OPA support):**
```rego
isExcludedLocation(vuln) if {
    some location in vuln.locations
    some exclusion
    exclusion = data.exclusions.locations[_]
    regex.match(exclusion, location.file)
}
```

### 5.4 Add/Remove Severity Levels

If you removed `low` severity from measures:

```rego
# Remove this entire block:
low := count([
    v |
    v := detail.vulnerabilities[_]
    check := isOk("low", v, data.vulnerabilities.low.exceptions)
    violation := { ... }
    fianu.record_violation(check, violation)
    not check
])

# And remove this check:
low <= data.vulnerabilities.low.maximum
```

If you added `informational` severity:

```rego
informational := count([
    v |
    v := detail.vulnerabilities[_]
    check := isOk("informational", v, data.vulnerabilities.informational.exceptions)
    violation := {
        "level": v.level,
        "identifier": v.identifier,
        "description": v.description,
        "cwe": v.cwe
    }
    fianu.record_violation(check, violation)
    not check
])

# Add check in pass rule:
informational <= data.vulnerabilities.informational.maximum
```

### 5.5 Customize Violation Output

The violation object is what gets recorded when a check fails. Include fields that are useful for debugging:

```rego
violation := {
    "level": v.level,
    "identifier": v.identifier,
    "description": v.description,
    "cwe": v.cwe,
    "file": v.locations[0].file,          # Add file path
    "priority": v.priority,                 # Add priority score
    "package": v.locations[0].package      # Add package name
}
```

---

## Step 6: Create Test Data

### 6.1 Policy Test Cases

**inputs/data/policy_strict.json** - Zero tolerance:
```json
{
  "required": true,
  "vulnerabilities": {
    "critical": {
      "maximum": 0,
      "exceptions": []
    },
    "high": {
      "maximum": 0,
      "exceptions": []
    },
    "medium": {
      "maximum": 5,
      "exceptions": []
    },
    "low": {
      "maximum": 20,
      "exceptions": []
    }
  },
  "exclusions": {
    "locations": []
  }
}
```

**inputs/data/policy_lenient.json** - With exceptions:
```json
{
  "required": true,
  "vulnerabilities": {
    "critical": {
      "maximum": 0,
      "exceptions": ["CVE-2023-1234", "CWE-79"]
    },
    "high": {
      "maximum": 10,
      "exceptions": []
    },
    "medium": {
      "maximum": 50,
      "exceptions": []
    },
    "low": {
      "maximum": 200,
      "exceptions": []
    }
  },
  "exclusions": {
    "locations": ["test/", "vendor/", ".github/"]
  }
}
```

### 6.2 Occurrence Test Cases

Create at least 3 occurrence files:

**testing/payloads/occ_passing.json** - Clean scan:
- No vulnerabilities, or only low severity
- Should pass with strict policy

**testing/payloads/occ_failing.json** - Scan with violations:
- Multiple critical and high vulnerabilities
- Should fail with strict policy
- Should pass with lenient policy (due to exceptions)

**testing/payloads/occ_edge_cases.json** - Edge cases:
- Empty results array
- Missing optional fields
- Null values
- Tests mapper robustness

Use REAL data from your tool. Export an actual scan result and save it.

---

## Step 7: Test Everything

### 7.1 Test Mapper

```bash
python3 -c "
import sys, json
sys.path.insert(0, 'mappers')
import detail

# Test passing case
occ = json.load(open('testing/payloads/occ_passing.json'))
result = detail.main(occ, {})
print('Passing case:')
print(json.dumps(result, indent=2))

# Test failing case
occ = json.load(open('testing/payloads/occ_failing.json'))
result = detail.main(occ, {})
print('\nFailing case:')
print(json.dumps(result, indent=2))

# Test edge cases
occ = json.load(open('testing/payloads/occ_edge_cases.json'))
result = detail.main(occ, {})
print('\nEdge cases:')
print(json.dumps(result, indent=2))
"
```

**Expected output:**
- No errors/exceptions
- Correct vulnerability counts
- All fields present
- Edge cases handled gracefully

### 7.2 Validate Files

```bash
# Validate YAML
python3 -c "import yaml; yaml.safe_load(open('spec.yaml'))"

# Validate JSON files
for file in contents.json inputs/data/*.json testing/payloads/*.json; do
    echo "Validating $file"
    python3 -c "import json; json.load(open('$file'))"
done
```

### 7.3 Test Rule (if OPA installed)

```bash
# Package rule
opa build rule/rule.rego

# Evaluate with test data
opa eval -d rule/rule.rego \
  -i testing/payloads/occ_passing.json \
  -d inputs/data/policy_strict.json \
  "data.rule.pass"
```

### 7.4 Check TODOs

```bash
# Find any remaining TODOs
grep -r "TODO" .
```

All TODOs should be replaced!

---

## Step 8: Deploy

### 8.1 Package

```bash
fianu package --path . -o my-scanner-control.tgz
```

**If this fails:**
- Check that `contents.json` references all files correctly
- Verify all referenced files exist
- Check file permissions

### 8.2 Deploy to Dev

```bash
export FIANU_CLIENT_ID="your-dev-client-id"
export FIANU_CLIENT_SECRET="your-dev-client-secret"
export FIANU_HOST="https://fianu-dev.fianu.io"

fianu apply --path my-scanner-control.tgz
```

### 8.3 Test with Real Data

1. Configure a policy in the UI
2. Run your security scan
3. Check if control evaluates correctly
4. Verify violations show up properly
5. Test with different policies

### 8.4 Deploy to Production

Once tested in dev:

```bash
export FIANU_HOST="https://fianu.fianu.io"
fianu apply --path my-scanner-control.tgz
```

---

## Common Customizations

### Add More Exception Types

**Measure (spec.yaml):**
```yaml
- name: package_exceptions
  type: metric
  value: array.string
  node_id: <NEW_UUID>
```

**Policy (inputs/data):**
```json
{
  "vulnerabilities": {
    "critical": {
      "maximum": 0,
      "exceptions": [],
      "package_exceptions": ["lodash", "axios"]
    }
  }
}
```

**Rule (rule.rego):**
```rego
isPackageException(vuln) if {
    some location in vuln.locations
    some exception
    exception = data.vulnerabilities.critical.package_exceptions[_]
    exception == location.package
}
```

### Change Threshold Logic

**Allow violations if total is below threshold:**
```rego
pass if {
    detail := input.detail
    summary := detail.summary

    # Instead of checking each level individually
    # Check total across all levels
    total := summary.critical + summary.high + summary.medium + summary.low
    total <= data.total_maximum
}
```

### Add Time-Based Logic

**Only fail if vulnerability is recent:**
```rego
isRecent(vuln) if {
    # Assume vuln has timestamp field
    vuln_time := time.parse_rfc3339_ns(vuln.timestamp)
    current_time := time.now_ns()
    age_days := (current_time - vuln_time) / 86400000000000

    age_days <= 30  # Only fail on vulnerabilities found in last 30 days
}

pass if {
    critical := count([
        v |
        v := detail.vulnerabilities[_]
        v.level == "critical"
        isRecent(v)  # Only count recent vulnerabilities
        not isException(v, data.vulnerabilities.critical.exceptions)
    ])

    critical <= data.vulnerabilities.critical.maximum
}
```

### Add Custom Severity Mapping

**Handle tool-specific severity values:**
```python
# detail.py
SEVERITY_MAP = {
    'CRITICAL': 'critical',
    'ERROR': 'critical',
    'HIGH': 'high',
    'WARNING': 'medium',
    'MEDIUM': 'medium',
    'LOW': 'low',
    'INFO': 'informational',
    'NOTE': 'informational'
}

def normalize_severity(tool_severity):
    """Normalize tool-specific severity to standard levels."""
    return SEVERITY_MAP.get(tool_severity.upper(), 'low')
```

### Add Metadata to Display

**Show scan timestamp, tool version:**
```python
# display.py
def main(occurrence, attestation, context):
    _detail = occurrence.get('detail', {})
    _summary = _detail.get('summary', {})
    _scan = _detail.get('scan', {})

    critical = _summary.get('critical', 0)
    high = _summary.get('high', 0)

    # Include scan metadata in tag
    scan_date = _scan.get('timestamp', 'Unknown')
    tool_version = _scan.get('version', 'N/A')

    return {
        'description': f"Security scan (v{tool_version}) from {scan_date}",
        'tag': f'Critical: {critical}, High: {high}'
    }
```

---

## Troubleshooting

### "TypeError: 'NoneType' object is not subscriptable"
- Add `.get()` with defaults for all dictionary access
- Test with edge case occurrence (empty/null values)

### "KeyError: 'vulnerabilities'"
- Check that detail mapper returns correct structure
- Verify occurrence test data has expected fields

### "Rule always passes/fails"
- Add debug output: `trace(sprintf("count: %v", [count]))`
- Verify policy structure matches rule expectations
- Check that measure names match exactly

### "Violations not showing"
- Ensure `fianu.record_violation()` is called
- Check violation object includes all fields
- Verify display.py columns match violation fields

### "Package fails"
- Check contents.json references correct file paths
- Ensure all files exist
- Verify no syntax errors in YAML/JSON

---

## Next Steps

- [Deploy your control](../../deployment/)
- [Add more patterns](../../patterns/)
- [Share with community](../../contributing/)
- [Create more test cases](../../TROUBLESHOOTING.md)

---

**Need more help?** → [GitHub Discussions](https://github.com/fianulabs/official-controls/discussions)

**Found a bug?** → [GitHub Issues](https://github.com/fianulabs/official-controls/issues)
