# Vulnerability Scanner Template

Complete, production-ready template for creating vulnerability scanning controls (SAST, SCA, container scanning, etc.).

## What This Template Does

This template evaluates security scan results against policy thresholds for different severity levels:
- **Critical** vulnerabilities: Strict limits (usually 0)
- **High** vulnerabilities: Low limits
- **Medium** vulnerabilities: Moderate limits
- **Low** vulnerabilities: Higher limits

It includes:
- Exception handling (exclude specific CVEs/CWEs)
- Location exclusions (ignore certain files/paths)
- SARIF format parsing (standard security scan format)
- Comprehensive violation tracking

## Use This Template For

- ✅ SAST tools (Snyk, Checkmarx, Fortify, etc.)
- ✅ SCA tools (Snyk, WhiteSource, etc.)
- ✅ Container scanners (Wiz, Aqua, Trivy, etc.)
- ✅ Secret scanners (GitLab Secret Detection, etc.)
- ✅ Any tool that reports vulnerabilities with severity levels

## Files Included

```
vulnerability-scanner/
├── README.md                           # This file
├── CUSTOMIZATION.md                    # Detailed customization guide
├── spec.yaml.template                  # Control specification with TODOs
├── contents.json                       # Component references
├── mappers/
│   ├── detail.py                      # SARIF parsing with comments
│   └── display.py                     # UI formatting
├── rule/
│   └── rule.rego                      # Severity-based evaluation
├── inputs/
│   └── data/
│       ├── policy_strict.json         # Zero-tolerance policy
│       └── policy_lenient.json        # Policy with exceptions
└── testing/
    └── payloads/
        ├── occ_passing.json           # Clean scan
        ├── occ_failing.json           # Scan with violations
        └── occ_edge_cases.json        # Empty results, null handling
```

## Quick Start

### 1. Copy This Template

```bash
# Copy to your control directory
cp -r templates/vulnerability-scanner my-scanner-control
cd my-scanner-control
```

### 2. Customize Files

Replace all `TODO` markers in these files:
- `spec.yaml.template` (IDs, names, integration paths)
- `mappers/detail.py` (data extraction logic)
- `testing/payloads/*.json` (realistic test data)

See [CUSTOMIZATION.md](CUSTOMIZATION.md) for detailed instructions.

### 3. Rename Template File

```bash
mv spec.yaml.template spec.yaml
```

### 4. Test Locally

```bash
# Test the detail mapper
python3 -c "
import sys, json
sys.path.insert(0, 'mappers')
import detail
occ = json.load(open('testing/payloads/occ_passing.json'))
print(json.dumps(detail.main(occ, {}), indent=2))
"

# Validate YAML
python3 -c "import yaml; yaml.safe_load(open('spec.yaml'))"
```

### 5. Deploy

```bash
# Package
fianu package --path . -o my-scanner-control.tgz

# Deploy
fianu apply --path my-scanner-control.tgz
```

## Customization Areas

### Required Customizations

**spec.yaml.template:**
- [ ] Generate new UUIDs for `id` and all `node_id` fields
- [ ] Set `displayKey` (e.g., SNYK, CKMX, WIZ)
- [ ] Set `path` (e.g., snyk.sast.vulnerabilities)
- [ ] Set `name` and `fullName`
- [ ] Update `relations[0].subscription.path` (occurrence path)
- [ ] Update `relations[0].subscription.integration.path` (plugin name)

**mappers/detail.py:**
- [ ] Update data extraction to match your tool's format
- [ ] If not using SARIF, replace parsing logic entirely
- [ ] Adjust severity level mapping if needed

**testing/payloads/*.json:**
- [ ] Replace with realistic data from your tool
- [ ] Include all severity levels
- [ ] Test edge cases (empty results, missing fields)

### Optional Customizations

**Add more severity levels:**
- Update measures in spec.yaml
- Add evaluation logic in rule.rego
- Update display.py tag

**Change exception types:**
- Modify `exceptions` array structure
- Update `isException()` helper in rule.rego
- Update policy test cases

**Add more exclusion types:**
- Add new measure sections
- Update rule logic
- Update policy test cases

## How It Works

### Data Flow

```
1. Security scan runs → produces occurrence data
2. detail.py extracts and structures vulnerability data
3. rule.rego evaluates against policy thresholds
4. display.py formats results for UI
5. Violations are recorded for each threshold breach
```

### Policy Configuration

Users configure thresholds for each severity level:

```json
{
  "required": true,
  "vulnerabilities": {
    "critical": {
      "maximum": 0,
      "exceptions": ["CVE-2023-1234"]
    },
    "high": {
      "maximum": 5,
      "exceptions": []
    }
  },
  "exclusions": {
    "locations": ["test/", "vendor/"]
  }
}
```

### Evaluation Logic

The rule evaluates each severity level independently:

1. Count vulnerabilities at each level
2. Exclude exceptions (CVE/CWE matches)
3. Exclude location matches
4. Check if count ≤ maximum threshold
5. Record violations for items exceeding threshold

## SARIF Format Support

This template includes complete SARIF parsing:
- Extract results from `runs[0].results`
- Map rule IDs to rule definitions
- Extract CWE, categories, tags
- Parse file locations
- Handle priority scores

If your tool doesn't use SARIF, see [CUSTOMIZATION.md](CUSTOMIZATION.md) for guidance on adapting the mapper.

## Common Tool Adaptations

### Snyk (SARIF)
- ✅ Works out of box
- Change integration path to `snyk-sast` or `snyk-sca`
- Adjust CWE extraction if needed

### Checkmarx (API Response)
- Replace SARIF parsing with API response extraction
- Map `criticalSeverity`, `highSeverity` fields
- Extract scan ID, project name, URL

### Wiz (Containers)
- Keep SARIF structure
- Update display description to mention containers
- Add package name to violation details

### GitLab Secret Detection (SARIF)
- ✅ Works out of box
- Simplify to single severity level if needed
- Focus on location exclusions

### Custom Tool (Non-SARIF)
- Replace entire `parse_sarif()` function
- Keep the same return structure:
  ```python
  {
    'summary': { 'critical': 0, 'high': 0, ... },
    'vulnerabilities': [ ... ]
  }
  ```
- Vulnerabilities should include: `level`, `identifier`, `description`, `locations`

## Testing Strategy

### Test Cases Included

**policy_strict.json:**
- Zero tolerance for critical/high
- No exceptions
- Tests fail scenario

**policy_lenient.json:**
- Allows some high/medium vulnerabilities
- Includes CVE exceptions
- Includes location exclusions
- Tests pass scenario

**occ_passing.json:**
- Clean scan or only low severity issues
- Tests pass scenario

**occ_failing.json:**
- Multiple critical and high vulnerabilities
- Tests fail scenario
- Includes violations for display

**occ_edge_cases.json:**
- Empty results array
- Missing fields
- Null values
- Tests robustness

### Testing Workflow

1. **Mapper Test**: Verify data extraction works
   ```bash
   python3 mappers/detail.py  # Should output structured data
   ```

2. **Rule Test**: Verify policy evaluation (requires OPA)
   ```bash
   opa eval -d rule/rule.rego "data.rule.pass"
   ```

3. **Integration Test**: Deploy to dev and test with real occurrence

## Troubleshooting

### "Mapper fails with KeyError"
- Check if occurrence structure matches expected format
- Add `.get()` with defaults for all nested access
- Test with edge case payload

### "Rule always fails/passes"
- Verify policy structure matches rule expectations
- Check `data.*` paths in rule.rego
- Add debug output: `trace(sprintf("critical count: %v", [critical]))`

### "Violations not showing in UI"
- Verify `fianu.record_violation()` is called
- Check that violation object includes all fields
- Match violation fields to display.py columns

### "Parser doesn't work for my tool"
- If not SARIF, replace parsing logic entirely
- Keep the return structure consistent
- Start simple, add complexity incrementally

## Best Practices

### DO:
- ✅ Start with realistic test data from your actual tool
- ✅ Test both pass and fail scenarios
- ✅ Include edge cases (empty, null, malformed)
- ✅ Add comments explaining tool-specific logic
- ✅ Keep mapper logic simple and focused
- ✅ Handle all null/undefined cases gracefully

### DON'T:
- ❌ Skip the TODO replacements in spec.yaml
- ❌ Reuse UUIDs from this template
- ❌ Deploy without testing locally first
- ❌ Assume your tool uses SARIF format
- ❌ Hardcode values that should be policy-configurable
- ❌ Ignore error handling in mappers

## Pattern Reference

This template uses these patterns from [patterns/](../../patterns/):
- **severity-based-evaluation** - Multi-level threshold checking
- **exception-handling** - CVE/CWE exceptions
- **location-exclusions** - File path filtering
- **sarif-parsing** - SARIF format extraction
- **summary-aggregation** - Violation counts by severity

## Further Reading

- **[CUSTOMIZATION.md](CUSTOMIZATION.md)** - Detailed customization guide
- **[Getting Started](../../GETTING_STARTED.md)** - First-time control creation
- **[Core Concepts](../../CONCEPTS.md)** - Understanding control architecture
- **[Recipes](../../recipes/)** - Tool-specific implementations
- **[Patterns](../../patterns/)** - Reusable code patterns
- **[Reference](../../reference/)** - Complete technical reference

## Examples Using This Template

Real-world controls built from this template:
- **snyk.sast.vulnerabilities** - Snyk SAST scanning
- **wiz.containerscan.vulnerabilities** - Wiz container scanning
- **gitlab.secretscanning** - GitLab secret detection
- **checkmarx.sast.analysis** - Checkmarx SAST scanning

See the [official controls repository](../..) for complete implementations.

## Support

- **Questions**: [GitHub Discussions](https://github.com/fianulabs/official-controls/discussions)
- **Issues**: [GitHub Issues](https://github.com/fianulabs/official-controls/issues)
- **General Help**: [Troubleshooting Guide](../../TROUBLESHOOTING.md)

---

**Ready to customize?** → [CUSTOMIZATION.md](CUSTOMIZATION.md)

**Need tool-specific guidance?** → [Recipes](../../recipes/)

**Want to understand the patterns?** → [Patterns](../../patterns/)
