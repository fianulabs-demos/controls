"""
Detail Mapper - Vulnerability Scanner Template

This mapper extracts and structures vulnerability data from security scan results.
It includes complete SARIF format parsing with extensive comments.

If your tool doesn't use SARIF, replace the SARIF-specific functions while keeping
the same return structure.

See CUSTOMIZATION.md for detailed guidance on adapting this mapper.
"""


def get_result_rule(rule_id, rules):
    """
    Find a rule definition by its ID.

    SARIF stores rule definitions separately from results. This helper
    looks up the full rule definition given a rule ID.

    Args:
        rule_id: The rule ID to look up (e.g., "javascript/sql-injection")
        rules: List of rule definitions from SARIF tool.driver.rules

    Returns:
        dict: The matching rule definition, or empty dict if not found
    """
    for rule in rules:
        if rule.get('id') == rule_id:
            return rule
    return {}


def map_sarif_level_to_severity(sarif_level, priority_score=0):
    """
    Map SARIF level to standard severity.

    SARIF uses "error", "warning", "note", "none" as levels.
    This function maps them to standard severity levels using both
    the level and optional priority score.

    Args:
        sarif_level: SARIF level ("error", "warning", "note", "none")
        priority_score: Optional priority score (0-1000)

    Returns:
        str: Standard severity ("critical", "high", "medium", "low", "informational")
    """
    # TODO: Customize this mapping based on your tool
    # Different tools may use different thresholds

    if sarif_level == "error":
        # High priority errors are critical
        if priority_score >= 800:
            return "critical"
        return "high"
    elif sarif_level == "warning":
        # Medium priority warnings vary
        if priority_score >= 500:
            return "medium"
        return "low"
    elif sarif_level == "note":
        return "informational"
    else:
        return "low"


def extract_cwes(rule):
    """
    Extract CWE identifiers from a SARIF rule.

    Different tools store CWEs in different places within SARIF.
    This function handles common locations.

    Args:
        rule: SARIF rule definition

    Returns:
        list: List of CWE strings (e.g., ["CWE-79", "CWE-89"])
    """
    # TODO: Adjust based on where your tool stores CWEs

    properties = rule.get('properties', {})

    # Option 1: Direct CWE array
    cwes = properties.get('cwe', [])
    if cwes:
        return cwes

    # Option 2: In tags
    tags = properties.get('tags', [])
    cwes = [tag for tag in tags if tag.startswith('CWE-')]
    if cwes:
        return cwes

    # Option 3: In security-severity field
    security = properties.get('security-severity', '')
    if security and 'CWE' in security:
        # Parse "CWE-79, CWE-89" format
        return [cwe.strip() for cwe in security.split(',') if 'CWE' in cwe]

    # Option 4: In precision field
    precision = properties.get('precision', '')
    if 'CWE' in precision:
        return [precision]

    return []


def extract_locations(result):
    """
    Extract file locations from a SARIF result.

    Args:
        result: SARIF result object

    Returns:
        list: List of location dicts with file paths and line numbers
    """
    locations = []

    for location in result.get('locations', []):
        physical_location = location.get('physicalLocation', {})
        artifact_location = physical_location.get('artifactLocation', {})

        # Extract file path
        file_path = artifact_location.get('uri', '')

        # Extract line number range
        region = physical_location.get('region', {})
        start_line = region.get('startLine', 0)
        end_line = region.get('endLine', start_line)

        locations.append({
            'file': file_path,
            'startLine': start_line,
            'endLine': end_line
        })

    return locations


def parse_sarif_result_to_vulnerability(result, tool):
    """
    Convert a SARIF result to a standardized vulnerability object.

    This is the core parsing function that extracts all relevant data
    from a SARIF result and its associated rule definition.

    Args:
        result: SARIF result object from runs[].results[]
        tool: SARIF tool object from runs[].tool

    Returns:
        dict: Standardized vulnerability object
    """
    # Get rule definitions
    rules = tool.get('driver', {}).get('rules', [])

    # Look up the full rule definition for this result
    rule_id = result.get('ruleId', '')
    rule = get_result_rule(rule_id, rules)

    # Extract severity
    sarif_level = result.get('level', 'warning')
    priority_score = result.get('properties', {}).get('priorityScore', 0)
    severity = map_sarif_level_to_severity(sarif_level, priority_score)

    # Extract message/description
    message = result.get('message', {}).get('text', '')

    # Extract CWEs from rule
    cwes = extract_cwes(rule)

    # Extract categories/tags
    rule_properties = rule.get('properties', {})
    categories = rule_properties.get('categories', [])
    tags = rule_properties.get('tags', [])

    # Extract locations
    locations = extract_locations(result)

    # Build standardized vulnerability object
    return {
        'level': severity,
        'identifier': rule_id,
        'description': message,
        'cwe': cwes,
        'categories': categories,
        'tags': tags,
        'priority': priority_score,
        'locations': locations
    }


def parse_sarif(occurrence):
    """
    Parse SARIF format occurrence data.

    SARIF (Static Analysis Results Interchange Format) is a standard
    format for security tool output. This function extracts all
    vulnerability data from a SARIF document.

    Args:
        occurrence: Occurrence with SARIF data in detail.scan

    Returns:
        dict: Structured vulnerability data with summary and details
    """
    # Extract SARIF data from occurrence
    # TODO: Adjust this path based on where SARIF data is in your occurrence
    sarif_data = occurrence.get('detail', {}).get('scan', {})

    # SARIF structure: { runs: [ { results: [...], tool: {...} } ] }
    runs = sarif_data.get('runs', [])

    if not runs:
        # No scan data - return empty results
        return {
            'summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'informational': 0,
                'total': 0
            },
            'vulnerabilities': [],
            'scan': {}
        }

    # Usually only one run, take the first
    run = runs[0]

    # Extract results and tool info
    results = run.get('results', [])
    tool = run.get('tool', {})

    # Parse each result into a vulnerability
    vulnerabilities = []
    for result in results:
        vuln = parse_sarif_result_to_vulnerability(result, tool)
        vulnerabilities.append(vuln)

    # Generate summary counts by severity
    summary = {
        'critical': 0,
        'high': 0,
        'medium': 0,
        'low': 0,
        'informational': 0,
        'total': len(vulnerabilities)
    }

    for vuln in vulnerabilities:
        level = vuln.get('level', 'low')
        if level in summary:
            summary[level] += 1

    # Extract scan metadata (optional)
    # TODO: Customize based on what metadata your tool provides
    properties = run.get('properties', {})
    scan_metadata = {
        'coverage': properties.get('coverage', ''),
        'timestamp': properties.get('timestamp', ''),
        'version': tool.get('driver', {}).get('version', '')
    }

    return {
        'summary': summary,
        'vulnerabilities': vulnerabilities,
        'scan': scan_metadata
    }


def parse_custom_format(occurrence):
    """
    Parse custom (non-SARIF) format occurrence data.

    If your tool doesn't use SARIF, implement your parsing logic here.
    Keep the same return structure as parse_sarif().

    Args:
        occurrence: Occurrence with tool-specific data

    Returns:
        dict: Structured vulnerability data (same format as parse_sarif)
    """
    # TODO: Replace this with your tool's parsing logic

    # Example: Checkmarx-style API response
    occ = occurrence.get('detail', {})
    scan_details = occ.get('scanDetails', {})
    result_stats = scan_details.get('resultStatistics', {})

    # Extract summary from tool's format
    summary = {
        'critical': result_stats.get('criticalSeverity', 0),
        'high': result_stats.get('highSeverity', 0),
        'medium': result_stats.get('mediumSeverity', 0),
        'low': result_stats.get('lowSeverity', 0),
        'informational': result_stats.get('infoSeverity', 0),
        'total': result_stats.get('totalSeverity', 0)
    }

    # Extract individual results
    results = occ.get('results', [])
    vulnerabilities = []

    for result in results:
        vuln = {
            'level': result.get('severity', 'low').lower(),
            'identifier': result.get('vulnerabilityId', ''),
            'description': result.get('description', ''),
            'cwe': [result.get('cweId', '')],
            'categories': result.get('categories', []),
            'tags': result.get('tags', []),
            'priority': result.get('priority', 0),
            'locations': [{
                'file': result.get('fileName', ''),
                'startLine': result.get('line', 0),
                'endLine': result.get('line', 0)
            }]
        }
        vulnerabilities.append(vuln)

    # Extract scan metadata
    scan_metadata = {
        'id': scan_details.get('scanId', ''),
        'project': scan_details.get('projectName', ''),
        'url': scan_details.get('reportLink', ''),
        'timestamp': scan_details.get('scanDate', '')
    }

    return {
        'summary': summary,
        'vulnerabilities': vulnerabilities,
        'scan': scan_metadata
    }


def main(occurrence, context):
    """
    Main entry point for the detail mapper.

    This function determines the data format and calls the appropriate parser.

    Args:
        occurrence: Raw occurrence data from integration
        context: Execution context (tenant, asset info, etc.)

    Returns:
        dict: Structured vulnerability data for rule evaluation
    """
    # TODO: Determine which parser to use based on your data format

    # Option 1: Use SARIF parser (recommended if your tool supports SARIF)
    return parse_sarif(occurrence)

    # Option 2: Use custom parser (if your tool has a proprietary format)
    # return parse_custom_format(occurrence)

    # Option 3: Hybrid approach - try SARIF first, fall back to custom
    # try:
    #     return parse_sarif(occurrence)
    # except (KeyError, IndexError):
    #     return parse_custom_format(occurrence)


# For local testing
if __name__ == '__main__':
    import sys
    import json

    # Load test occurrence
    if len(sys.argv) > 1:
        with open(sys.argv[1]) as f:
            test_occurrence = json.load(f)
    else:
        print("Usage: python detail.py <occurrence.json>")
        sys.exit(1)

    # Run mapper
    result = main(test_occurrence, {})

    # Print formatted result
    print(json.dumps(result, indent=2))
